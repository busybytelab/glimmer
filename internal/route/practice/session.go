package practice

import (
	"encoding/json"
	"fmt"
	"net/http"
	"regexp"
	"strings"
	"time"

	"github.com/busybytelab.com/glimmer/internal/domain"
	"github.com/busybytelab.com/glimmer/internal/llm"
	"github.com/pocketbase/pocketbase/core"
	"github.com/rs/zerolog/log"
)

type (
	SessionRoute interface {
		HandleCreatePracticeSession(e *core.RequestEvent) error
	}

	sessionRoute struct {
		llmService llm.Service
	}

	// CreatePracticeSessionRequest defines the request body
	CreatePracticeSessionRequest struct {
		LearnerId       string `json:"learnerId"`
		PracticeTopicId string `json:"practiceTopicId"`
		SystemPrompt    string `json:"systemPrompt,omitempty"`
		BasePrompt      string `json:"basePrompt,omitempty"`
	}

	// PracticeItemResponse defines the structure for a practice item generated by LLM
	PracticeItemResponse struct {
		QuestionText            string            `json:"question_text"`
		QuestionType            string            `json:"question_type"`
		Options                 []string          `json:"options,omitempty"`
		CorrectAnswer           string            `json:"correct_answer"`
		Explanation             string            `json:"explanation"`
		ExplanationForIncorrect map[string]string `json:"explanation_for_incorrect,omitempty"`
		Hints                   []string          `json:"hints,omitempty"`
		DifficultyLevel         string            `json:"difficulty_level,omitempty"`
	}

	// LLMResponseItems is a container for practice items from LLM
	LLMResponseItems struct {
		Items []PracticeItemResponse `json:"items"`
	}
)

func NewPracticeSessionRoute(llmService llm.Service) SessionRoute {
	return &sessionRoute{
		llmService: llmService,
	}
}

func (r *sessionRoute) HandleCreatePracticeSession(e *core.RequestEvent) error {
	// 1. Parse request JSON body
	var req CreatePracticeSessionRequest
	if err := e.BindBody(&req); err != nil {
		return e.BadRequestError("Invalid request body", err)
	}

	// Validate request
	if req.LearnerId == "" || req.PracticeTopicId == "" {
		return e.BadRequestError("LearnerId and PracticeTopicId are required", nil)
	}

	// 2. Load learner from DB
	learner, err := e.App.FindRecordById(domain.CollectionLearners, req.LearnerId)
	if err != nil {
		log.Error().Err(err).Str("learnerId", req.LearnerId).Msg("Failed to find learner")
		return e.NotFoundError("Learner not found", err)
	}

	// Load topic from DB
	topic, err := e.App.FindRecordById(domain.CollectionPracticeTopics, req.PracticeTopicId)
	if err != nil {
		log.Error().Err(err).Str("topicId", req.PracticeTopicId).Msg("Failed to find practice topic")
		return e.NotFoundError("Practice topic not found", err)
	}

	// 3. Get base prompt and system prompt from practiceTopic or request if provided
	basePrompt := topic.GetString("base_prompt")
	systemPrompt := topic.GetString("system_prompt")

	// Use provided prompts if they exist
	if req.BasePrompt != "" {
		basePrompt = req.BasePrompt
	}

	if req.SystemPrompt != "" {
		systemPrompt = req.SystemPrompt
	}

	// Set default system prompt if not provided
	if systemPrompt == "" {
		systemPrompt = "You are an expert educational content creator specialized in creating practice exercises for students."
	}

	// 4. Append the json generation instruction to the base prompt
	generationPrompt := buildGenerationPrompt(basePrompt, topic.GetString("name"), topic.GetString("subject"), topic.GetString("account"), e)

	// 5. Ask LLM to create practice items
	// Get user name from the expanded relation
	userId := learner.GetString("user")
	var userName string
	if user, err := e.App.FindRecordById("_pb_users_auth_", userId); err == nil {
		userName = user.GetString("name")
	} else {
		userName = userId
	}

	log.Info().
		Str("learner", userName).
		Str("topic", topic.GetString("name")).
		Msg("Generating practice items using LLM")

	// Get the LLM model from the practice topic, if not set, the service will use default
	llmModel := topic.GetString("llm_model")
	var chatOptions []llm.ChatOption
	if llmModel != "" {
		chatOptions = append(chatOptions, llm.WithModel(llmModel))
	}

	llmResponse, _, err := r.llmService.Chat(generationPrompt, systemPrompt, chatOptions...)
	if err != nil {
		log.Error().Err(err).Msg("Failed to generate practice items using LLM")
		return e.InternalServerError("Failed to generate practice items", err)
	}

	// 6. Parse LLM JSON, cleaning up the response if needed
	practiceItems, err := parseAndCleanLLMResponse(llmResponse)
	if err != nil {
		log.Error().Err(err).Msg("Failed to parse LLM response")
		return e.InternalServerError("Failed to parse generated practice items", err)
	}

	// Get account ID from learner
	accountId := learner.GetString("account")

	// 7. Create practice item records in DB
	practiceItemIds, err := createPracticeItems(e, practiceItems, topic.Id, accountId)
	if err != nil {
		log.Error().Err(err).Msg("Failed to create practice items in database")
		return e.InternalServerError("Failed to save practice items", err)
	}

	// 8. Create practice session
	practiceSession, err := createPracticeSession(e, topic.Id, learner.Id, practiceItemIds, generationPrompt, accountId)
	if err != nil {
		log.Error().Err(err).Msg("Failed to create practice session")
		return e.InternalServerError("Failed to create practice session", err)
	}

	// Return the created practice session
	return e.JSON(http.StatusOK, practiceSession)
}

// buildGenerationPrompt constructs a detailed prompt for the LLM to generate practice items
func buildGenerationPrompt(basePrompt, topicName, subject string, accountId string, e *core.RequestEvent) string {
	// Get account to retrieve the prompt extension template
	account, err := e.App.FindRecordById(domain.CollectionAccounts, accountId)
	if err != nil {
		log.Error().Err(err).Str("accountId", accountId).Msg("Failed to find account, using default prompt extension")
		// We'll continue with an empty extension if there's an error
	}

	// Get the prompt extension from the account, or use an empty string if not available
	promptExtension := ""
	if account != nil {
		promptExtension = account.GetString("practice_session_default_prompt_extension")
	}

	// Combine with base prompt
	combinedPrompt := fmt.Sprintf("%s\n\nTopic: %s\nSubject: %s\n\n%s",
		basePrompt,
		topicName,
		subject,
		promptExtension)
	// Escape any JSON special characters in the prompt to ensure it's JSON-safe
	escapedPrompt := strings.ReplaceAll(combinedPrompt, `"`, `\"`)
	escapedPrompt = strings.ReplaceAll(escapedPrompt, `\`, `\\`)
	escapedPrompt = strings.ReplaceAll(escapedPrompt, "\n", `\n`)
	escapedPrompt = strings.ReplaceAll(escapedPrompt, "\t", `\t`)
	escapedPrompt = strings.ReplaceAll(escapedPrompt, "\r", `\r`)

	return escapedPrompt
}

// parseAndCleanLLMResponse parses the LLM response, handling common formatting issues
func parseAndCleanLLMResponse(response string) ([]PracticeItemResponse, error) {
	// Clean up the response by removing code blocks and unnecessary characters
	cleanResponse := cleanLLMResponse(response)

	// Try to parse the response as JSON
	var itemsContainer LLMResponseItems
	err := json.Unmarshal([]byte(cleanResponse), &itemsContainer)
	if err != nil {
		log.Error().Err(err).Str("response", cleanResponse).Msg("Failed to unmarshal LLM response")
		return nil, fmt.Errorf("invalid JSON in LLM response: %w", err)
	}

	// Validate items
	if len(itemsContainer.Items) == 0 {
		return nil, fmt.Errorf("no practice items found in LLM response")
	}

	return itemsContainer.Items, nil
}

// cleanLLMResponse cleans up the LLM response by removing code blocks and unnecessary characters
func cleanLLMResponse(response string) string {
	// Remove markdown code blocks if present
	codeBlockRegex := regexp.MustCompile("(?s)```(?:json)?(.+?)```")
	matches := codeBlockRegex.FindStringSubmatch(response)
	if len(matches) > 1 {
		return strings.TrimSpace(matches[1])
	}

	// If no code blocks, just clean the string
	return strings.TrimSpace(response)
}

// createPracticeItems creates practice items in the database and returns their IDs
func createPracticeItems(e *core.RequestEvent, items []PracticeItemResponse, topicId, accountId string) ([]string, error) {
	practiceItemIds := make([]string, 0, len(items))

	for _, item := range items {
		// Create a new practice item record
		collection, err := e.App.FindCollectionByNameOrId(domain.CollectionPracticeItems)
		if err != nil {
			return nil, fmt.Errorf("failed to find practice_items collection: %w", err)
		}

		newItem := core.NewRecord(collection)

		// Convert options and hints to JSON strings
		optionsJson, err := json.Marshal(item.Options)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal options: %w", err)
		}

		hintsJson, err := json.Marshal(item.Hints)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal hints: %w", err)
		}

		explanationForIncorrectJson, err := json.Marshal(item.ExplanationForIncorrect)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal explanation_for_incorrect: %w", err)
		}

		// Wrap correct answer in quotes and then marshal to JSON
		correctAnswerJson, err := json.Marshal(item.CorrectAnswer)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal correct_answer: %w", err)
		}

		// Set fields
		newItem.Set("question_text", item.QuestionText)
		newItem.Set("question_type", item.QuestionType)
		newItem.Set("options", string(optionsJson))
		newItem.Set("correct_answer", string(correctAnswerJson))
		newItem.Set("explanation", item.Explanation)
		newItem.Set("explanation_for_incorrect", string(explanationForIncorrectJson))
		newItem.Set("hints", string(hintsJson))
		newItem.Set("difficulty_level", item.DifficultyLevel)
		newItem.Set("status", "Generated")
		newItem.Set("practice_topic", topicId)
		newItem.Set("account", accountId)
		newItem.Set("tags", "[]") // Empty tags array

		// Save the practice item
		if err := e.App.Save(newItem); err != nil {
			return nil, fmt.Errorf("failed to save practice item: %w", err)
		}

		practiceItemIds = append(practiceItemIds, newItem.Id)
	}

	return practiceItemIds, nil
}

// createPracticeSession creates a practice session in the database
func createPracticeSession(e *core.RequestEvent, topicId, learnerId string, itemIds []string, generationPrompt, accountId string) (*core.Record, error) {
	// Create a new practice session record
	collection, err := e.App.FindCollectionByNameOrId(domain.CollectionPracticeSessions)
	if err != nil {
		return nil, fmt.Errorf("failed to find practice_sessions collection: %w", err)
	}

	session := core.NewRecord(collection)

	// Convert item IDs to JSON string array
	// The format should be: ["id1", "id2", "id3"]
	itemIdsJsonString, err := json.Marshal(itemIds)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal practice item IDs: %w", err)
	}

	// Generate a name for the session
	sessionName := fmt.Sprintf("Practice Session - %s", time.Now().Format("2006-01-02"))

	// Set fields
	session.Set("name", sessionName)
	session.Set("learner", learnerId)
	session.Set("practice_topic", topicId)
	session.Set("practice_items", string(itemIdsJsonString))
	// Workflow status (e.g., 'Generated', 'NeedsReview', 'Approved', 'Rejected')
	session.Set("status", "Generated")
	session.Set("assigned_at", time.Now())
	session.Set("generation_prompt", generationPrompt)
	session.Set("account", accountId)

	// Save the practice session
	if err := e.App.Save(session); err != nil {
		return nil, fmt.Errorf("failed to save practice session: %w", err)
	}

	return session, nil
}
